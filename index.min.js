const t=async r=>(r=await r,Array.isArray(r)?await Promise.all(r.map(t)):r),r=(t,r)=>(...n)=>(t=>t instanceof RegExp?t.test.bind(t):t)(t).call(r,...n),n=(t,n)=>async(e,a,i)=>({value:e,extra:await r(t,n)(e,a,i)}),e=({extra:t})=>t,a=({value:t})=>t,i={every:async(t,n,e)=>{for(let a=0;a<t.length;a++){if(!await r(n,e)(t[a],a,t))return!1}return!0},filter:async(r,i,o)=>(await t(r.map(n(i,o)))).filter(e).map(a),find:async(t,n,e)=>{for(let a=0;a<t.length;a++){if(await r(n,e)(t[a],a,t))return t[a]}},findIndex:async(t,n,e)=>{for(let a=0;a<t.length;a++){if(await r(n,e)(t[a],a,t))return a}return-1},forEach:async(r,e,a)=>(await t(r.map(n(e,a))),r),reduce:async(t,n,e)=>{const a=void 0!==e;a||(e=t[0]);for(let i=a?0:1;i<t.length;i++)e=await r(n)(e,t[i],i,t);return e},reduceRight:async(t,n,e)=>{const a=void 0!==e;a||(e=t[t.length-1]);for(let i=t.length-(a?1:2);i>=0;i--)e=await r(n)(e,t[i],i,t);return e},some:async(t,n,e)=>{for(let a=0;a<t.length;a++){if(await r(n,e)(t[a],a,t))return!0}return!1}},o=(r,n)=>(e,a)=>"then"===a?(...n)=>t(r).then(...n):"catch"===a?(...n)=>c(t(r).catch(...n)):y(t(r).then((t=>"symbol"==typeof a?t[a]:a in n?y(((...r)=>n[a](t,...r)),n):"number"==typeof t&&a in n.number?y(((...r)=>n.number[a](t,...r)),n):"string"==typeof t&&a in n.string?y(((...r)=>n.string[a](t,...r)),n):Array.isArray(t)&&a in n.array?y(((...r)=>n.array[a](t,...r)),n):t[a]&&t[a].bind?y(t[a].bind(t),n):y(t[a],n))),n),s=(r,n)=>(e,a,i)=>y(t(r).then((t=>{return"function"!=typeof t?(r=`You tried to call "${JSON.stringify(t)}" (${typeof t}) as a function, but it is not.`,Promise.reject(new Error(r))):t(...i);var r})),n),y=(t,r)=>new Proxy((()=>{}),{get:o(t,r),apply:s(t,r)});export default function c(t,{number:r,string:n,array:e,...a}={}){return"function"==typeof t?(...i)=>c(Promise.all(i).then((r=>t(...r))),{number:r,string:n,array:e,...a}):new Proxy({},{get:o(t,{number:{...r},string:{...n},array:{...i,...e},...a})})}