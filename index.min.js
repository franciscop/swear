const r=async t=>(t=await t,Array.isArray(t)?await Promise.all(t.map(r)):t),t=(r,t)=>(...e)=>(r=>r instanceof RegExp?r.test.bind(r):r)(r).call(t,...e),e=(r,e)=>async(a,n,i)=>({value:a,extra:await t(r,e)(a,n,i)}),a=({extra:r})=>r,n=({value:r})=>r,i={every:async(r,e,a)=>{for(let n=0;n<r.length;n++){if(!await t(e,a)(r[n],n,r))return!1}return!0},filter:async(t,i,o)=>(await r(t.map(e(i,o)))).filter(a).map(n),find:async(r,e,a)=>{for(let n=0;n<r.length;n++){if(await t(e,a)(r[n],n,r))return r[n]}},findIndex:async(r,e,a)=>{for(let n=0;n<r.length;n++){if(await t(e,a)(r[n],n,r))return n}return-1},forEach:async(t,a,n)=>(await r(t.map(e(a,n))),t),reduce:async(r,e,a)=>{const n=void 0!==a;n||(a=r[0]);for(let i=n?0:1;i<r.length;i++)a=await t(e)(a,r[i],i,r);return a},reduceRight:async(r,e,a)=>{const n=void 0!==a;n||(a=r[r.length-1]);for(let i=r.length-(n?1:2);i>=0;i--)a=await t(e)(a,r[i],i,r);return a},some:async(r,e,a)=>{for(let n=0;n<r.length;n++){if(await t(e,a)(r[n],n,r))return!0}return!1}},o=(t,e)=>(a,n)=>"then"===n?(...e)=>r(t).then(...e):"catch"===n?(...e)=>swear(r(t).catch(...e)):y(r(t).then((r=>"symbol"==typeof n?r[n]:n in e?y(((...t)=>e[n](r,...t)),e):"number"==typeof r&&n in e.number?y(((...t)=>e.number[n](r,...t)),e):"string"==typeof r&&n in e.string?y(((...t)=>e.string[n](r,...t)),e):Array.isArray(r)&&n in e.array?y(((...t)=>e.array[n](r,...t)),e):r[n]&&r[n].bind?y(r[n].bind(r),e):y(r[n],e))),e),s=(t,e)=>(a,n,i)=>y(r(t).then((r=>{return"function"!=typeof r?(t=`You tried to call "${JSON.stringify(r)}" (${typeof r}) as a function, but it is not.`,Promise.reject(new Error(t))):r(...i);var t})),e),y=(r,t)=>new Proxy((()=>{}),{get:o(r,t),apply:s(r,t)});export default swear=(r,{number:t,string:e,array:a,...n}={})=>"function"==typeof r?(...i)=>swear(Promise.all(i).then((t=>r(...t))),{number:t,string:e,array:a,...n}):new Proxy({},{get:o(r,{number:{...t},string:{...e},array:{...i,...a},...n})});